本地缓存
    一般而言，本地缓存是一级缓存，分布式缓存是二级缓存
    1. 缓存穿透：用户恶意访问无意义数据，因为无意义数据不会在保存在缓存中，导致大量恶意请求直奔 DB 导致问题。
        1. 解决方案：将无意义的数据也缓存起来，并设置较短的过期时间
    2. 缓存击穿：某一个热点数据，缓存过期，导致所有请求直奔 DB 的现象
    3. 缓存雪崩：大量缓存全部失效。由于设置了固定的缓存过期时间，导致某个时间多个缓存同时过期的现象；缓存服务器宕机
        1. 解决方案1：随机设置缓存过期时间
        2. 解决方案2：搭建缓存服务器集群

分布式缓存
    如何实现缓存服务器负载均衡？
        解决方案：使用 Hash 函数计算，将流量打倒不同的缓存服务器上
        存在的问题：新增缓存服务器会导致大量缓存失效
        案例：假设原先有 2 台服务器，hash 算法为对 2 取余，值为 0 的缓存请求，打到 A 服务器，1 的打到 B 服务器上，          
             现在新增 1 台 C 服务器，hash 算法变更为对 3 取余，这样会导致部分甚至全部缓存失效。
             比如原先 key=4 的缓存，取余后会打到 A 服务器，hash 算法变更后会打到 B 服务器上，
             而 B 服务器上没有该 key 的缓存，这就是缓存失效的原因
             
    如何解决新增服务器导致原先大量缓存失效的问题？
        解决方案：使用 Hash 环算法
        算法案例：假设 hash 环为 0～99 数字组成的环，一开始有 A B 两台服务器，A 在 49 号位，B 在 99 号位，
                当 hash 值在 0～49 之间时，打到 A 上，在 50～99 之间时，打到 B 上
                现在新增一台 C，在 75 号位上，那么 50～75 之间的缓存请求打到 C 上，76～99 的打到 B 上
                这样原先 0～49 和 76～99 的缓存不会失效，失效的只有 50～75 之间的缓存
        存在的问题：当 Hash 环新增服务器后，会出现 Hash 倾斜问题（因 hash 算法，导致缓存服务器在 Hash 环上分布不均匀的问题）
                    
    如何解决 hash 环新增服务器时，导致的 hash 倾斜问题？
        解决方案：假设有 20 台虚拟服务器均匀的分布在 hash 环上，比如 5,10,15,...
                然后将虚拟服务器映射到对应的真实服务器 A B 上，如果新增真实服务器 C，则只需将映射关系改到 C 上即可
    
    缓存一致性问题怎么解决（如何保证缓存中的值和数据库中的值一致）？
        从 DB 读取数据，说明缓存无数据，且读取完后需要更新缓存  
        当 DB 更新后，立刻删除缓存(推荐使用)：
            有问题的执行顺序： 线程 A 读取 DB 为 99 -> 线程 B 更新 DB 为 98 -> 线程 B 删除 Cache -> 线程 A 更新 Cache 为 99
            以上执行顺序出现的可能性很小
            解决方案：加锁 或者 读写分离
        当 DB 更新后，立刻更新缓存：
            有问题的执行顺序： 线程 A 更新 DB 为 99 -> 线程 B 更新 DB 为 98 -> 线程 B 更新 Cache 为 98 -> 线程 A 更新 Cache 为 99 
        先删除缓存，再更新 DB :
            有问题的执行顺序： 线程 A 删除 Cache -> 线程 B 从 DB 读取数据 98  -> 线程 B 更新 Cache 为 98  -> 线程 A 更新 DB 97
        先更新缓存，在更新 DB:
            有问题的执行顺序： A1 -> B1 -> B2 -> A2
    
                    
                    
                    
