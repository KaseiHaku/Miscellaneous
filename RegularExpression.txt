/** TODO Regular Expression Special Characters */
^$
()[]{}
?+*
|
.\


/** TODO Operator Precedence 运算符优先级 */
\                                                   转义符
(), (?:), (?=), (?!), (?<=), (?<!), []              圆括号和方括号
*, +, ?, {n}, {n,}, {n,m}                           限定符
^, $, \任何元字符、任何字符                           定位点和序列（即：位置和顺序）
|                                                   替换，"或"操作
字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"



/** TODO Locator Characters 定位符 */
^       // 匹配字符串开始位置
$       // 匹配字符串结束位置
\b      // 匹配单词边界，即字与空格间的位置，注意不是空格
\B      // 匹配非单词边界






// [] 表达式，里面表示的是 单个字符 如果是什么都不加 表示是一个 固定顺序的字符串
[xyz]"state": "open",
"attributes": {},
"branchRadio": 0,
字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
[^xyz]          负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
[a-z]           字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[^a-z]          负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
[a-zA-Z0-9] 

            

// () 子表达式， 如果不加 （） 那么前面所有的算一个表达式
(x|y)              // 匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。

(regexp)           //匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
(?:regexp)         //匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。

/** TODO  (positive|negative)(lookahead|lookbehind) 
 * @trap 坑：反向预搜索一般的 正则表达式引擎 只支持字符串，不支持在预搜索中使用 正则表达式，java 的正则表达式引擎支持固定数量的重复，即 {0,9} 但是不支持不固定数量的重复
 * */
(?=regexp)         // 正向预搜索，肯定。预查windows后面的字符，若和pattern相同则匹配这个windows，否则不匹配;这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!regexp)         // 正向预搜索，否定。预查windows后面的字符，若和pattern相同则不匹配这个windows，否则匹配。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?<=text)          // 反向预搜索，肯定。
(?<!text)          // 反向预搜索，否定。



对一个正则表达式模式或部分模式两边添加圆括号将导致这部分表达式存储到一个临时缓冲区buffer[99]中；使用‘?:’,'?=','?!'可忽略对这部分正则表达式的保存。
所捕获的每个子匹配都按照在正则表达式中从左至右的顺序存储，存储字匹配的缓冲区编号从1开始，直到最大99个字表达式，
每个缓冲区都可使用‘\n’访问，n为标识特定缓冲区的一位或两位十进制数

一对小括号就是一个捕获组：(()())() 这当中有4个捕获组 其中 \1 表示的最外面的捕获组, \3 是嵌套括号中的第二个括号；即哪个左括号'('先出现，哪个捕获组序列号在前

// 量词
{n}             // n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}            // n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}           // m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
  
?               // 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
+               // 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
*               // 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
?               当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。

坑： 当可以匹配 0 次的时候，会匹配空串，即 "" 啥都没有
坑： 如果要再 js 代码中匹配 ? * + 需要添加 \\?  \\* \\+ 因为第一个 \ 用来转义 第二个 \， 第二个 \ 才是用来转义 ? * +  的

// 预定义匹配字符
.       // 匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \.
\cx     // 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\f      // 匹配一个换页符。等价于 \x0c 和 \cL。
\n      // 匹配一个换行符。等价于 \x0a 和 \cJ。
\r      // 匹配一个回车符。等价于 \x0d 和 \cM。
\t      // 匹配一个制表符。等价于 \x09 和 \cI。
\v      // 匹配一个垂直制表符。等价于 \x0b 和 \cK。

\s      // 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S      // 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。


\d      // 匹配一个数字字符。等价于 [0-9]。
\D      // 匹配一个非数字字符。等价于 [^0-9]。

\w      // 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W      // 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。

\xn     // 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
\un     // 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)

\num    // 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
\n      // 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm     // 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml    // 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。



  

/** TODO Example Demo Template */
^ \b windows (?= ([xyz]? [^0-9] (k|s\r){3,7}? \x41 \u00A9) ) \3 \cM \B $            // 集大成的正则表达式
^(?!([0-9]|[a-z]|[A-Z]){0,})$                                                       // 匹配向前预查找的写法：
^[^0-9,a-z,A-Z]$                                                                    // 不匹配
^(kasei|ksf)haku$                                                                   // 匹配多个


