什么是程序程序？
    写在 txt 文件中的 cpu 的指令集，静态概念
    
什么是进程？
    是一个操作系统级别的概念，是操作系统分配调度资源的基本单位，动态概念
    
什么是线程？
    是一个 cpu 级别的改您，是 cpu 时间片资源分配调度的基本单位
    
进程和线程的区别？
    线程之间共享一个进程中操作系统分配的所有资源，
    进程之间不相互影响，但线程之间相互影响，一个线程死掉就等于这个进程中所有线程一起死掉（即这个进程整个死掉），
    因为线程时进程的一部分，是进程的一条执行路径
    一个程序 = n个进程，一个进程 = n个线程

线程的状态有哪些：
                                    ┌─         阻塞状态               ─┐
                               {阻塞的解除}                      {导致阻塞的事件}         
                                    │                                  │           
    新生状态  ─ {执行start方法 } ─ 就绪状态  ─ {CPU调度并分配时间片} ─  运行状态 ─ {运行结束或kill} ─  死亡状态

线程的操作：
    join
    yield
    sleep： 不释放锁资源

    wait：表示等待当前实例（对象）的锁
    notify: 通知等待当前实例的锁的线程，随机通知一个
    notifyAll: 通知全部

停止线程方法：
    1、线程体正常执行结束
    2、设置 flag 标志停止线程

阻塞/非阻塞，同步/异步：
    阻塞：指主线程碰到一个阻塞代码（如 IO）时，是开启子线程去运行阻塞代码，让主线程直接过;还是让主线程去阻塞等待
    同步：指轮询其他线程（包括在不同 host 中的线程）的结果，
    异步：指存在回调函数，由其他线程（包括不同 host 中的线程）通知你已经执行完成


什么是原子性操作：
    一串动作要么全执行，要么全不执行，没有被打断的情况
    
计算机是如何实现原子性的?
    由于 CPU 在一次时钟周期内，只能做一次 01 变换，所以只要是能在一个时钟周期内完成的 CPU 指令，那就是具有原子性的指令，即是原子性操作

代码如何实现原子性？
    加锁

多线程同步问题：
    出现场景：多线程同时操作共享变量时，才会出现同步问题
    解决方法：同一时刻只能有一个线程操作共享变量，这是线程同步的唯一方法
    实现方案：synchronized：底层 monitor 实现， Lock

线程间通信的方法有哪些？：
    轮询：自己不断的去查看某个标志是否存在
    回调：事件发生之后，调用自己

线程等待锁的方式有哪些？
    自旋：相当于轮询，线程一直在运行，用户态，无需进行线程上下文切换，适用于读多写少的情况，乐观锁，极其占用 CPU
    阻塞：相当于回调，线程进入阻塞状态，内核态，需要进行线程上下文切换，适用于...，悲观锁

什么是死锁?
    不同程序相互等待对方独占的资源释放       
       
死锁的检测算法有哪些？
    针对每种资源只有一个实例的情况
        构建资源分配图，采用深度优先遍历算法确定是否存在环路：
            依次将每一个节点作为一棵树的根节点，进行深度优先搜索，如果再次碰到已经遇到过的节点，那么就算找到了一个环
    针对每种资源还有多个实例的情况
        构建向量矩阵（资源池），
            依据现有资源，查找一个分配后能运行完毕的进程，依次类推
    
死锁恢复算法有哪些？
    抢占：不通知原进程的情况下，将某一资源从一个进程强行取走供另一个进程使用，用完后送回
    回滚：周期性的将进程状态存档，检测到死锁时，从一个较早的存档点恢复
    杀死进程：杀死死锁环中的一个或多个进程；杀死一个环外的进程以释放该进程的资源


死锁的预防方法有哪些？
    主要是破坏死锁的四个必要条件：
        1. 资源使用互斥条件：一个资源只能被一个进程使用
        2. 请求保持条件：一个进程持有资源的同时申请资源
            破坏该条件的方法：
                a. 一个进程运行前必须一次性申请整个运行过程所需的全部资源
                b. 要求一个进程申请新资源前，必须释放它所占有的所有资源，然后在依次性申请所有所需资源
        3. 不可抢占条件：进程已经获得的资源，在未使用完之前，不能强行剥夺，只能进程使用完后自己释放
            破坏该条件的方法：
                a. 如果已经占用一定资源的进程，再次提交申请资源请求，且申请请求被拒绝，则该进程必须释放它所有占有的资源
                b. 如果一个进程请求一个被另一个进程占有的资源，操作系统可以抢占另一个进程，要求它释放资源。该方法只有在两个进程优先级不同的条件下才有效
        4. 循环等待条件：系统中若干进程组成环路，该环路中每个进程等待下一个进程所占用的资源
            破坏该条件的方法：
                a. 保证每一个进程在任何时刻只能占用一个资源，若要请求另外一个资源，它必须先释放第一个资源。
                b. 将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。

什么是安全序列？
    是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{P1，P2，...，Pn}就是安全序列
    
银行家算法是什么？
    多个进程同时申请某个资源，只给获取资源后能完成当前事件的进程分配资源。
    例如：有三个客户C1，C2，C3 同时向银行家借款，银行家总共有10个资金单位，
        其中C1客户要借9各资金单位，但已经占用2个，缺7个
        C2客户要借3个资金单位，但已经占用2个，缺1个
        C3客户要借8个资金单位，但已经占用4个，缺4个
        所以银行家只剩余 2 个资金单位，
        那么银行家先给C2分配资源，让C2完成事件，并返回3个资源，然后再借给C3，然后再借给C1

### Lock
> 锁的实现方式只有两种：共享内存、消息传递
- 悲观锁： 一个线程访问共享数据时，禁止其他线程对该共享数据进行操作  
- 乐观锁： 线程访问共享数据时，读的时候保存一个该数据的版本到内存暂存，写的时候再次读取该数据的版本，如果前后版本一致，则写入，否则回滚  
- 读写锁： 指读取数据的时候不对数据加锁，只有执行写操作的时候才对数据加锁  
- 可重入锁：指一个具有对象 A 锁的线程能直接进入其他同样需要 A 对象锁的代码块，而不需要重新获取 A 对象的锁才能进入  
- 不可中断锁：指一个线程 A 想获取一把锁 lock，但是 lock 锁已经被占用，那么线程 A 只能一直阻塞等待 lock 锁被释放，而不能中途不等了，而去执行其他代码。  
- 可中断锁：指线程 A 等待锁 lock，但是 lock 被线程 B 占用，第一种情况， A 可以主动打断 B 线程的执行，让 B 释放锁；第二种情况， A 可以主动退出等待 lock 锁。        

- 临界区(Critical Section)： 
    > 保证同一时刻，只有一个线程能访问临界区中的资源
    > 只能在同一进程内
    > 操作原语：
    >     EnterCriticalSection() // 进入临界区 
    >     LeaveCriticalSection() // 离开临界区 
        
- 互斥量(Mutex)： 
    > 只有拥有互斥对象的线程才具有访问资源的权限，跟临界区很相似，但是临界区是根据线程来标志资源的可访问性，互斥量是根据一个互斥实例（对象）来标志资源的可访问性
    > 可以跨进程
    > 操作原语：
    >     CreateMutex() // 创建一个互斥量 
    >     OpenMutex() // 打开一个互斥量 
    >     ReleaseMutex() // 释放互斥量 
    >     WaitForMultipleObjects() // 等待互斥量对象

- 信号量(Semaphores)： 
    > 是指同一时间，访问共享资源的线程的最大数量
    > 跟操作系统的 PV 操作相似，P 申请资源 V 释放资源
    > 可跨进程
    > 操作原语：
    >     CreateSemaphore() // 创建一个信号量 
    >     OpenSemaphore() // 打开一个信号量 
    >     ReleaseSemaphore() // 释放信号量 
    >     WaitForSingleObject() // 等待信号量
    
- 事件(Event)： 
    > 用来通知线程有一些事件已发生，从而启动后继任务的开
    > 可跨进程






分布式锁的实现方式
    数据库唯一约束
    Redis
    Zookeeper
    以上三个都有问题，相对而言 Zookeeper 最好
