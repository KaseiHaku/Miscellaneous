单机事务 
    四大特性 
        Atomicity      原子性：要么全部成功，要么全部失败  
        Consistency    一致性：指事务出错，所有状态回滚  
        Isolation      隔离性：并行事务之间互不影响  
        Durability     持久性：事务成功，所有数据持久化到硬盘，即是系统崩溃断电都不影响  
    实现方法
        JDBC 设置 autoCommit(false), 如果出错 rollback();

事务隔离级别
    术语简介
        脏读：读取了还没有提交的数据   
        不可重复读：事务 A 前后两次相同的 select ，得到同一 row 的数据不同   
        幻读：重复读的特殊情况，事务 A 前后两次相同的 select ，得到 row 的条数不同，即其他事务新插入了一条符合 select 条件的数据
        快照读： 读取 快照/缓存 中的数据， select ...;  为快照读
        当前读： 永远读取当前最新的数据，select ... lock in share mode; selct ... for update; insert; delete; update; 为当前读
        行锁： 只锁对应的行数据，不锁整张表
            S 锁(shared lock/共享锁/读锁)： 
                若事务 A 对 row1 加上 S 锁，那么事务 B 可以对 row1 进行 查，但是不能 增删改
                sql> select ... lock in share mode; 加 S 锁
            X 锁(exclusive lock/排他锁/写锁)： 
                若事务 A 对 row1 加上 X 锁，那么事务 B 不能对 row1 进行 增删改查
                sql> select ... for update; 加 X 锁
                sql> insert; delete; update; 加 X 锁
    隔离级别
        Read uncommitted 读未提交：     
            B 事务可以读取 A 事务没有提交的数据。且 B 事务可以在 A 事务进行时执行任何操作（CURD）  
            可能出现: 脏读、不可重复读、幻读
        Read committed 读已提交：       
            指 B 事务只能读取到 A 事务已经提交的数据。且 B 事务可以在 A 事务进行时执行任何操作（CURD）
            可能出现: 不可重复读、幻读
        Repeatable read 重复读：      
            A 事务 在 B 事务 执行过程中不能对 B 事务  正在操作的数据，做 增、删、改 操作，能做查询
            可能出现： 幻读
        Serializable 序列化：         
            当 A 事务开始后，B 事务不能对该记录进行任何操作，包括读操作
            不会出现任何问题
    
    坑：
        1. 即使 事务隔离级别 为 可重复读，事务A select 如果不加 S 或者 X 锁，那么 其他 事务B 依然能够修改 事务A select 出来的 row 的数据

Distributed Transaction 分布式事务解决方案
    分布式事务解决方案基本思路：  
        重试（正向补偿）：当被调代码调用不成功时，重复调用，直到成功为止  
        回滚（逆向回滚）：要求调用者 提供一个逆向操作的接口 供被调者使用，被调代码失败时，调用逐级往上调用 逆向接口 回滚所有数据  

    XA Transaction, 2PC: Two Phase Commit 两阶段提交  
        由一个协调者和多个参与者组成，类似 master-slaver 结构  
        协调者：事务管理器，TM   
        参与者：资源管理器，RM  
        两阶段是指：  
            1. 准备(Prepare)阶段: 当事务开始时，协调者向所有的参与者发送 Prepare 消息，请求执行事务。
               参与者接收到消息后，要么同意，要么拒绝，如果同意，就会在本地执行事务，记录日志，但是不提交，并返回同意给协调者  
            2. 提交(Commit)阶段: 如果所有的参与者都同意，协调者再次给全部参与者发送提交请求。否则进行回滚  
        优点
            1. 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现
        缺点
            1. 事务管理器单点问题
            2. 同步阻塞：资源管理器中的资源在 Prepare 阶段后一直处于阻塞状态，直到提交完成
            3. 数据不一致性问题：Commit 阶段因为网络原因，资源管理器没有收到 commit 消息

    TCC: Try-Confirm-Cancel
        将事务转化未业务逻辑
        执行过程
            1. Try
               尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
            2. Confirm
               确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
            3. Cancel
               取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。
        优点
            解决了事务管理器单点问题
            解决了同步阻塞问题：引入了超时补偿，并且不会锁定整个资源，将资源转换成业务逻辑，粒度变小
            数据一致性：使用补偿机制，由业务活动管理器控制一致性
    
    本地消息表：
        架构：业务表 Biz， 消息表 Msg（包含 state 列：表示当前消息的状态），消息队列 MQ
        执行过程
            1. 依靠数据库本地事务，将 写 Biz，写 Msg（state=init），写 MQ 三个业务动作放在一个事务中
            2. 其他系统读取 MQ 中的消息，并消费，消费完成后修改 Msg state=finish
            3. 定时任务轮询消息表，查看是否有未完成的消息，有则再次放入 MQ 中，注意消息消费的幂等性
            
    消息队列
        本地消息表的变种，将本地消息表移到了 MQ 内部
       
    Saga 事务:
        一个事务 A 做三件事 1, 2, 3 将三件事使用各自的事务 t1,t2,t3 当有 t3 出错时，执行 t1,t2 的反向操作
        缺点: 无法保证 1，2，3 事务之间，其他事务的执行
    
    Paxos 算法：可以保证分布式事务严格一致性  

